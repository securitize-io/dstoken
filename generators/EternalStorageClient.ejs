pragma solidity ^0.4.21;

import '../zeppelin/ownership/Ownable.sol';
import './DSEternalStorage.sol';

/**
* @title EternalStorageClient
* @dev communicates with the eternal storage provider for a contract, providing convenience functions for accessing
* different types of variables
*
* NOTE: this is a AUTOMATICALLY GENERATED file, and can be OVERWRITTEN. it should not be manually edited.
*/


contract EternalStorageClient is Ownable {
  DSEternalStorage public eternalStorage;
  string public namespace;

  constructor(address _address, string _namespace) public {
    eternalStorage = DSEternalStorage(_address);
    namespace = _namespace;
  }

  function setStorage(address _address) onlyOwner internal {
    eternalStorage = DSEternalStorage(_address);
  }<% for (let i = 0 ; i < names.length ; i++) { %>

  /* <%=names[i]%> functions */

  function get<%=names[i]%>Generic(bytes encoded) view internal returns (<%=types[i]%>) {
    return eternalStorage.get<%=names[i]%>(keccak256(encoded));
  }

  function set<%=names[i]%>Generic(bytes encoded, <%=types[i]%> v) internal {
    eternalStorage.set<%=names[i]%>(keccak256(encoded), v);
  }

  function delete<%=names[i]%>Generic(bytes encoded) internal {
    eternalStorage.delete<%=names[i]%>(keccak256(encoded));
  }<% const functionArguments = functionArgumentsByType[types[i]] || [];
      for (let j = 0 ; j < functionArguments.length ; j++) {
      functionArguments[j] = functionArguments[j].split(",");
      const arguments = functionArguments[j].map((arg, k) => `${arg} p${k+1}`).join(",");
      const argumentTypes = functionArguments[j].map((arg) => abbrs[arg]).join("");
      const argumentsNoType = functionArguments[j].map((arg, k) => `p${k+1}`).join(",");
      const hasEightBit = functionArguments[j].includes('uint8') ? '8' : ''; %>

  function get<%=`${names[i]}${hasEightBit}`%>(<%= arguments %>) view internal returns (<%=types[i]%>) {
    return get<%=names[i]%>Generic(abi.encodePacked("<%= argumentTypes %>:",namespace,<%= argumentsNoType %>));
  }

  function set<%=`${names[i]}${hasEightBit}`%>(<%= arguments %>, <%=types[i]%> v) internal {
    set<%=names[i]%>Generic(abi.encodePacked("<%= argumentTypes %>:",namespace,<%= argumentsNoType %>), v);
  }

  function delete<%=`${names[i]}${hasEightBit}`%>(<%= arguments %>) internal {
    delete<%=names[i]%>Generic(abi.encodePacked("<%= argumentTypes %>:",namespace,<%= argumentsNoType %>));
  }<% } %><% } %>
}